// SPDX-License-Identifier: MIT
pragma solidity >=0.8.0;

import "../../src/DAO_HACK/DAO.sol";
import "../../src/DAO_HACK/attackDAO.sol";
import "forge-std/Test.sol";

contract DaoHackTest is Test {
    TheDAO public addressDao;
    uint256 depoitPerUser = 100 ether;
    
    address internal jake;
    address internal ethnical;
    address internal bhagui;
    address internal hacker;

    function setUp() public {
        addressDao = new TheDAO();

        vm.label(jake, "jake");
        vm.label(ethnical, "ethnical");
        vm.label(bhagui, "bagui");
        vm.label(hacker, "hacker");

        vm.deal(jake, 101 ether);
        vm.deal(ethnical, 101 ether);
        vm.deal(bhagui, 101 ether);
        vm.deal(hacker, 101 ether);

        addressDao.invest{value: depoitPerUser}(jake);
        addressDao.invest{value: depoitPerUser}(ethnical);
        addressDao.invest{value: depoitPerUser}(bhagui);
        
    }

    function testExploit() public {
        uint256 daoBalance = address(addressDao).balance / 1 ether;

        console.log("dao balance before exploit: %s", daoBalance);
    
        DaoAttack daoAttacker = new DaoAttack(payable(addressDao));
        daoAttacker.attack{value: 100 ether}();

        uint256 attackerBalance = address(daoAttacker).balance / 1 ether;

        uint256 daoBalanceAfter = address(addressDao).balance / 1 ether;

        //daoAttacker.withdrawEthToOwner();
        //uint256 hackerBalanceAfter = address(hacker).balance;
       
        console.log("attacker contract balance after exploit: %s", attackerBalance);
        console.log("dao balance after exploit: %s", daoBalanceAfter);


    }

}
